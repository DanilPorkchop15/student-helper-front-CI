# Описание архитектуры

## Архитектурные границы приложения

### Слой бизнес-логики

Вся бизнес-логика приложения сосредоточена на двух слоях `entities` и `features`:

* В `entities` описаны бизнес-сущности и интерфейсы.
* В `features` описаны обработчики пользовательских сценариев

**Данный слой должен быть полностью независим от следующих за ним слоев.**

### Слой Transport, он же API

В слое бизнес-логики описываются все интерфейсы, в том числе и интерфейсы api-адаптеров, по которым и будут реализованы
необходимые имплементации.
Интерфейсы и имплементации для api-адаптеров **должны** располагаться на слое `entities`.

Основное требование заключается в том, что все обращения к api должны быть сокрыты за Transport-интерфейсом.
Это позволит заменить конкретную реализацию api-адаптера, например на моковый.
Но при этом все остальные слои приложения не будут от него зависеть, т.к. зависеть они будут от Transport-интерфейса(
dependencies inversion).

**Данный слой может иметь зависимости от слоя бизнес-логики.**

### Слой UI

На данном слое должны располагаться компоненты, стили и прочие элементы, отвечающие за отображение.
Это могут быть как примитивы(кнопка, иконка и т.д.), так и страницы, основное требование заключается в отсутствии
бизнес-логики на данном слое.

Данный слой может иметь зависимость от слоя бизнес-логики. Прямая зависимость от слоя Transport - недопустима.

## Специфика

## Требования к моделям

В приложении можно выделить 5-видов базовых моделей для хранения данных:

### Модель для отображения и мутации(бизнес-модель)

1) Наследуется от базового класса `Model`
2) Хранится на слое `entities`

### Модель для форм создания и редактирования

1) Наследуется от базового класса `Model`
2) **Не допускается** использование бизнес-модель в данных целях
3) Может располагаться на слоях `features` и `entities`

### Модель для работы с табличными видами данных

1) Наследование от абстрактного класса `TableModule`
2) При отсутствии пагинации, фильтрации или сортировок, **необходимо** описать данные свойства в виде пустых моделей
3) В метод `_getData` **необходимо** имплементировать логику получения данных
4) Хранится на слое `entities`

### Модель фильтров

1) Наследование от `FilterParams`
2) Может располагаться на слоях `features`, при необходимости `entities`

### Модель синхронизированная с URL-строкой

1) Используется в случае необходимости вынесения query-параметров в url-строку. Это может быть полезно для
   реализации фильтров
2) Наследование от `ModelSyncWithUrl`
3) Может располагаться на слоях `features`, при необходимости `entities`

### Модель для сортировок

1) Наследование от `SortingParams`
2) Может располагаться на слоях `features`, при необходимости `entities`

### Модель для пагинации

1) Наследование от `PaginationParams`
2) Может располагаться на слоях `features`, при необходимости `entities`

## Требования к реализации

### Интерфейсы бизнес-слоя

- Все интерфейсы **должны** быть выделены в строго соответствующие файлы
- Все интерфейсы **должны** быть объеденины в директории `interfaces` в корне конкретного слайса
- Интерфейсы **должны** быть описаны исключительно на слоях `entities` и `features`
- В директории `interfaces` можно выделить базовые слайсы(их может быть и больше):
    - `domain` - интерфейсы сущности и зависимостей
    - `transport` - интерфейс для реализации api-адаптера
    - `dto` - интерфейсы для передачи в api-адаптер
    - `filter` - интерфейсы фильтров
    - `sorting` - интерфейсы сортировок
    - `service` - интерфейсы сервисов с бизнес-логикой

### API-адаптеры

- API-адаптеры **должны** располагаться в конкретном слайсе слоя `entity` в отдельном модуле `api`
- На уровне слайса **должен** быть описан интерфейс `Transport` для реализации адаптера
- Адаптер **должен** имплементировать интерфейс `Transport`
- Все получаемые данные с сервера **должны** быть декодированы и приведены к интерфейсам, описанным в доменном-слое
- Декодеры **должны** хранятся в том же сегменте `api`, что и сам адаптер
- Все запросы к API **должны** быть описаны через метод `createRequest`

### Работа с роутером

- Все существующие роуты приложения, **должны** быть вынесены в `shared/config/appRoutes`
- Любые ссылки и переходы к роутам, **должны** происходить через методы `appRoutes`
- Все основные роуты приложения **должны** быть описаны в `app/config.tsx`
- **Не допускается** распыление роутов по приложению
- **Не допускается** хранение идентификаторов, модификаторов и прочей информации необходимой для отображения страницы
  в `state`
- Приложение **должно** предоставлять возможность загрузки любой страницы из URL-ссылки

## Общие уточнения к шаблону

На основе шаблона разработано [приложение-пример](https://gitlab.worksolutions.ru/research_and_development/todo-front).
Для детального пониманию заложенных подходов и базовых инструментов, советуем ознакомиться с ним.

### Сегмент `lib`

Сегмент `lib` **должен** содержать утилиты и прочий вспомогательный код, но **не должен** содержать бизнес логику.
Расположение **следует** определять по области применения.

### Сегмент `entities/@common`

`entities/@common` вспомогательный слайс, который позволяет шарить между сущностями общую логику, интерфейсы,
декодеры, энкодеры и прочее.

### Инициализация RequestManager

В `app/hooks/requestManagerHook.ts` описаны базовые настройки для `RequestManager`, прописан `baseURL`, добавлена логика
обработки ошибок в запросах.
В случае необходимости обновления общего поведения `RequestManager`, делать это необходимо тут.

---
[Навигация](./navigation.md)
